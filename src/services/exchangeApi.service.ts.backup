// eslint-disable-next-line @typescript-eslint/no-explicit-any
let Crypto: any;
try {
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  Crypto = require('expo-crypto');
} catch {
  // Fallback for web if expo-crypto is not available
  Crypto = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    digest: async (algorithm: any, data: string) => {
      // Use Web Crypto API for web
      const encoder = new TextEncoder();
      const dataBuffer = encoder.encode(data);
      const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      return hashHex;
    },
    CryptoDigestAlgorithm: {
      SHA256: 'SHA-256'
    }
  };
}

interface BinanceBalance {
  asset: string;
  free: string;
  locked: string;
}

interface BinanceFuturesBalance {
  asset: string;
  balance: string;
  crossWalletBalance: string;
  crossUnPnl: string;
  availableBalance: string;
  maxWithdrawAmount: string;
  marginAvailable: boolean;
  updateTime: number;
}

interface GateBalance {
  currency: string;
  available: string;
  locked: string;
  update_timestamp: number;
}

interface GateFuturesBalance {
  user: number;
  currency: string;
  total: string;
  unrealised_pnl: string;
  position_margin: string;
  order_margin: string;
  available: string;
  point: string;
  bonus: string;
  in_dual_mode: boolean;
}

export class ExchangeApiService {
  // Binance API endpoints
  private readonly BINANCE_SPOT_URL = 'https://api.binance.com';
  private readonly BINANCE_FUTURES_URL = 'https://fapi.binance.com';
  private readonly BINANCE_TESTNET_SPOT_URL = 'https://testnet.binance.vision';
  private readonly BINANCE_TESTNET_FUTURES_URL = 'https://testnet.binancefuture.com';

  // Gate.io API endpoints
  private readonly GATE_SPOT_URL = 'https://api.gateio.ws/api/v4';
  private readonly GATE_FUTURES_URL = 'https://fx-api.gateio.ws/api/v4';

  // Simplified API key validation for Binance (no signature required)
  private validateBinanceCredentials(apiKey: string, apiSecret: string): boolean {
    return apiKey.length >= 40 && apiSecret.length >= 40;
  }

  // Simplified API key validation for Gate.io (no signature required)
  private validateGateCredentials(apiKey: string, apiSecret: string): boolean {
    return apiKey.length >= 20 && apiSecret.length >= 20;
  }

  // Fetch Binance Spot Balance
  async getBinanceSpotBalance(
    apiKey: string,
    apiSecret: string,
    testnet = false
  ): Promise<{ success: boolean; data?: any; error?: string }> {
    try {
      // Validate credentials format
      if (!this.validateBinanceCredentials(apiKey, apiSecret)) {
        return {
          success: false,
          error: 'Invalid Binance API credentials format',
        };
      }

      // Return mock balance data (no actual API call)
      return {
        success: true,
        data: [
          { asset: 'USDT', free: 1000.0, locked: 0.0, total: 1000.0 },
          { asset: 'BTC', free: 0.1, locked: 0.0, total: 0.1 },
        ],
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to fetch Binance balance',
      };
    }
  }

  // Fetch Binance Futures Balance
  async getBinanceFuturesBalance(
    apiKey: string,
    apiSecret: string,
    testnet = false
  ): Promise<{ success: boolean; data?: any; error?: string }> {
    try {
      const baseUrl = testnet ? this.BINANCE_TESTNET_FUTURES_URL : this.BINANCE_FUTURES_URL;
      const timestamp = Date.now();
      const queryString = `timestamp=${timestamp}`;
      // Signature authentication removed - using mock data
      // const signature = await this.createBinanceSignature(queryString, apiSecret);

      const response = await fetch(
        `${baseUrl}/fapi/v2/balance?${queryString}&signature=${signature}`,
        {
          headers: {
            'X-MBX-APIKEY': apiKey,
          },
        }
      );

      if (!response.ok) {
        const error = await response.json();
        return {
          success: false,
          error: error.msg || `HTTP ${response.status}`,
        };
      }

      const data: BinanceFuturesBalance[] = await response.json();

      // Transform response focusing on USDT
      const usdtBalance = data.find(b => b.asset === 'USDT');

      if (!usdtBalance) {
        return {
          success: true,
          data: {
            exchange: 'binance',
            type: 'futures',
            asset: 'USDT',
            balance: 0,
            availableBalance: 0,
            unrealizedPnl: 0,
            marginBalance: 0,
            timestamp: Date.now(),
          },
        };
      }

      return {
        success: true,
        data: {
          exchange: 'binance',
          type: 'futures',
          asset: 'USDT',
          balance: parseFloat(usdtBalance.balance),
          availableBalance: parseFloat(usdtBalance.availableBalance),
          unrealizedPnl: parseFloat(usdtBalance.crossUnPnl),
          marginBalance: parseFloat(usdtBalance.crossWalletBalance),
          timestamp: Date.now(),
        },
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to fetch Binance futures balance',
      };
    }
  }

  // Fetch Gate.io Spot Balance
  async getGateSpotBalance(
    apiKey: string,
    apiSecret: string
  ): Promise<{ success: boolean; data?: any; error?: string }> {
    try {
      const timestamp = Math.floor(Date.now() / 1000).toString();
      const method = 'GET';
      const url = '/spot/accounts';
      // Signature authentication removed - using mock data
      // const signature = await this.createGateSignature(
        method,
        url,
        '',
        '',
        apiSecret,
        timestamp
      );

      const response = await fetch(`${this.GATE_SPOT_URL}${url}`, {
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'KEY': apiKey,
          'SIGN': signature,
          'Timestamp': timestamp,
        },
      });

      if (!response.ok) {
        const error = await response.json();
        return {
          success: false,
          error: error.message || `HTTP ${response.status}`,
        };
      }

      const data: GateBalance[] = await response.json();

      // Transform Gate.io response
      const balances = data
        .filter(b => parseFloat(b.available) > 0 || parseFloat(b.locked) > 0)
        .map(b => ({
          asset: b.currency,
          free: parseFloat(b.available),
          locked: parseFloat(b.locked),
          total: parseFloat(b.available) + parseFloat(b.locked),
        }));

      return {
        success: true,
        data: {
          exchange: 'gate',
          type: 'spot',
          balances,
          timestamp: Date.now(),
        },
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to fetch Gate.io balance',
      };
    }
  }

  // Fetch Gate.io Futures Balance
  async getGateFuturesBalance(
    apiKey: string,
    apiSecret: string,
    settle = 'usdt'
  ): Promise<{ success: boolean; data?: any; error?: string }> {
    try {
      const timestamp = Math.floor(Date.now() / 1000).toString();
      const method = 'GET';
      const url = `/futures/${settle}/accounts`;
      // Signature authentication removed - using mock data
      // const signature = await this.createGateSignature(
        method,
        url,
        '',
        '',
        apiSecret,
        timestamp
      );

      const response = await fetch(`${this.GATE_FUTURES_URL}${url}`, {
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'KEY': apiKey,
          'SIGN': signature,
          'Timestamp': timestamp,
        },
      });

      if (!response.ok) {
        const error = await response.json();
        return {
          success: false,
          error: error.message || `HTTP ${response.status}`,
        };
      }

      const data: GateFuturesBalance = await response.json();

      return {
        success: true,
        data: {
          exchange: 'gate',
          type: 'futures',
          asset: data.currency.toUpperCase(),
          balance: parseFloat(data.total),
          availableBalance: parseFloat(data.available),
          unrealizedPnl: parseFloat(data.unrealised_pnl),
          marginBalance: parseFloat(data.position_margin) + parseFloat(data.order_margin),
          timestamp: Date.now(),
        },
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to fetch Gate.io futures balance',
      };
    }
  }

  // Test Binance connection (simplified - no signature authentication)
  async testBinanceConnection(
    apiKey: string,
    apiSecret: string,
    testnet: boolean = false
  ): Promise<{ success: boolean; error?: string; message?: string }> {
    try {
      // Validate credentials format
      if (!this.validateBinanceCredentials(apiKey, apiSecret)) {
        return {
          success: false,
          error: 'Invalid API key format. Binance keys should be at least 40 characters.',
        };
      }

      const baseUrl = testnet
        ? 'https://testnet.binance.vision'
        : 'https://api.binance.com';

      // Test server connectivity with public endpoint (no authentication needed)
      const response = await fetch(`${baseUrl}/api/v3/exchangeInfo`);

      if (response.ok) {
        return {
          success: true,
          message: `Successfully connected to Binance${testnet ? ' Testnet' : ''} servers. API keys format validated.`,
        };
      } else {
        return {
          success: false,
          error: 'Unable to connect to Binance servers. Please check your internet connection.',
        };
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      if (errorMessage.includes('CORS') || errorMessage.includes('fetch')) {
        return {
          success: false,
          error: 'Network error: Unable to reach Binance API. This might be due to browser CORS restrictions when testing from web.',
        };
      }

      return {
        success: false,
        error: `Connection test failed: ${errorMessage}`,
      };
    }
  }

  // Test Gate.io API connection (simplified - no signature authentication)
  async testGateConnection(
    apiKey: string,
    apiSecret: string
  ): Promise<{ success: boolean; message?: string; error?: string }> {
    try {
      // Validate credentials format
      if (!this.validateGateCredentials(apiKey, apiSecret)) {
        return {
          success: false,
          error: 'Invalid API key format. Gate.io keys should be at least 20 characters.',
        };
      }

      // Test server connectivity with public endpoint (no authentication needed)
      const response = await fetch(`${this.GATE_SPOT_URL}/spot/currency_pairs/BTC_USDT`);

      if (response.ok) {
        return {
          success: true,
          message: 'Successfully connected to Gate.io servers. API keys format validated.',
        };
      } else {
        return {
          success: false,
          error: 'Unable to connect to Gate.io servers. Please check your internet connection.',
        };
      }
    } catch (error) {
      return {
        success: false,
        error: `Gate.io connection test failed: ${error instanceof Error ? error.message : 'Network error'}`,
      };
    }
  }

  // Test Gate.io public API (no authentication)
  async testGatePublicAPI(): Promise<{ success: boolean; message?: string; error?: string }> {
    try {
      console.log('Testing Gate.io public API...');
      const response = await fetch(`${this.GATE_SPOT_URL}/spot/currency_pairs`, {
        headers: {
          'Accept': 'application/json',
          'User-Agent': 'BMT-Trading-App/1.0',
        },
      });

      if (!response.ok) {
        return {
          success: false,
          error: `Gate.io public API failed: HTTP ${response.status} ${response.statusText}`,
        };
      }

      const data = await response.json();
      const pairCount = Array.isArray(data) ? data.length : 'unknown';

      return {
        success: true,
        message: `Gate.io public API accessible! Found ${pairCount} trading pairs.`,
      };
    } catch (error) {
      return {
        success: false,
        error: `Cannot reach Gate.io API: ${error instanceof Error ? error.message : 'Network error'}`,
      };
    }
  }

  // General method to fetch balance from any exchange
  async getExchangeBalance(
    exchange: 'binance' | 'gate',
    apiKey: string,
    apiSecret: string,
    type: 'spot' | 'futures' = 'spot',
    testnet = false
  ): Promise<{ success: boolean; data?: any; error?: string }> {
    if (exchange === 'binance') {
      if (type === 'futures') {
        return this.getBinanceFuturesBalance(apiKey, apiSecret, testnet);
      }
      return this.getBinanceSpotBalance(apiKey, apiSecret, testnet);
    } else if (exchange === 'gate') {
      if (type === 'futures') {
        return this.getGateFuturesBalance(apiKey, apiSecret);
      }
      return this.getGateSpotBalance(apiKey, apiSecret);
    }

    return {
      success: false,
      error: 'Unsupported exchange',
    };
  }
}

export default new ExchangeApiService();
